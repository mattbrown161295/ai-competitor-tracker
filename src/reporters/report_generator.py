"""
Professional report generation in multiple formats (Markdown, JSON, HTML, CSV).
"""

import json
import csv
from typing import Dict, List, Any
from datetime import datetime
from pathlib import Path

from loguru import logger


class MarkdownReportGenerator:
    """Generates executive-style Markdown reports."""

    def generate(self, data: Dict[str, Any], output_path: str):
        """Generate comprehensive Markdown report."""
        articles = data.get("articles", [])
        stats = data.get("stats", {})
        timestamp = data.get("timestamp", datetime.now().isoformat())

        report_date = datetime.fromisoformat(timestamp).strftime("%B %d, %Y")

        markdown = f"""# AI Competitive Intelligence Report
**Generated:** {report_date}

---

## Executive Summary

- **Sources Monitored:** {stats.get('successful_sources', 0)}/{stats.get('total_sources', 0)}
- **New Developments:** {stats.get('articles_after_deduplication', 0)} articles
- **Data Quality:** {stats.get('invalid_articles', 0)} articles filtered, {stats.get('duplicates_removed', 0)} duplicates removed

---

## Critical Developments

"""

        # Add critical priority articles
        critical_articles = [a for a in articles if a.get("priority") == "critical"]
        if critical_articles:
            for article in critical_articles[:5]:  # Top 5 critical
                markdown += self._format_article(article)
        else:
            markdown += "*No critical developments in this period.*\n\n"

        markdown += """---

## Competitor Analysis

"""

        # Group articles by source
        articles_by_source = {}
        for article in articles:
            source = article.get("source", "Unknown")
            if source not in articles_by_source:
                articles_by_source[source] = []
            articles_by_source[source].append(article)

        # Generate section for each source
        for source, source_articles in sorted(articles_by_source.items()):
            markdown += f"### {source}\n\n"

            for article in source_articles[:3]:  # Top 3 per source
                markdown += self._format_article_compact(article)

            markdown += "\n"

        markdown += """---

## Data Quality Metrics

"""

        markdown += f"""
| Metric | Value |
|--------|-------|
| Total Sources Attempted | {stats.get('total_sources', 0)} |
| Successful Sources | {stats.get('successful_sources', 0)} |
| Failed Sources | {stats.get('failed_sources', 0)} |
| Raw Articles Collected | {stats.get('total_articles_raw', 0)} |
| After Validation | {stats.get('articles_after_validation', 0)} |
| After Deduplication | {stats.get('articles_after_deduplication', 0)} |
| Invalid/Filtered | {stats.get('invalid_articles', 0)} |
| Duplicates Removed | {stats.get('duplicates_removed', 0)} |
| Success Rate | {self._calculate_success_rate(stats)}% |

---

*Report generated by AI Competitor Intelligence Tracker*
"""

        # Write to file
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)
        output_file.write_text(markdown)

        logger.success(f"Markdown report saved to: {output_path}")

    def _format_article(self, article: Dict[str, Any]) -> str:
        """Format article in detailed style."""
        title = article.get("title", "No Title")
        source = article.get("source", "Unknown")
        date = article.get("date_formatted", "Date unknown")
        link = article.get("link", "#")
        summary = article.get("summary", article.get("content", ""))[:300]

        return f"""### {title}

**Source:** {source} | **Date:** {date}
**Link:** [{link}]({link})

{summary}...

---

"""

    def _format_article_compact(self, article: Dict[str, Any]) -> str:
        """Format article in compact style."""
        title = article.get("title", "No Title")
        date = article.get("date_formatted", "Date unknown")
        link = article.get("link", "#")

        return f"- **[{title}]({link})** - {date}\n"

    def _calculate_success_rate(self, stats: Dict[str, Any]) -> float:
        """Calculate overall success rate."""
        total = stats.get("total_sources", 0)
        successful = stats.get("successful_sources", 0)
        if total == 0:
            return 0.0
        return round((successful / total) * 100, 1)


class JSONReportGenerator:
    """Generates structured JSON reports."""

    def generate(self, data: Dict[str, Any], output_path: str):
        """Generate JSON report."""
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)

        with output_file.open("w") as f:
            json.dump(data, f, indent=2, default=str)

        logger.success(f"JSON report saved to: {output_path}")


class CSVReportGenerator:
    """Generates CSV reports for spreadsheet analysis."""

    def generate(self, data: Dict[str, Any], output_path: str):
        """Generate CSV report."""
        articles = data.get("articles", [])

        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)

        with output_file.open("w", newline="", encoding="utf-8") as f:
            if not articles:
                logger.warning("No articles to write to CSV")
                return

            # Define CSV columns
            fieldnames = [
                "source",
                "title",
                "date_formatted",
                "priority",
                "link",
                "summary",
                "processed_at",
            ]

            writer = csv.DictWriter(f, fieldnames=fieldnames, extrasaction="ignore")
            writer.writeheader()

            for article in articles:
                writer.writerow(article)

        logger.success(f"CSV report saved to: {output_path}")


class HTMLReportGenerator:
    """Generates interactive HTML dashboard."""

    def generate(self, data: Dict[str, Any], output_path: str):
        """Generate HTML dashboard."""
        articles = data.get("articles", [])
        stats = data.get("stats", {})
        timestamp = data.get("timestamp", datetime.now().isoformat())

        report_date = datetime.fromisoformat(timestamp).strftime("%B %d, %Y at %I:%M %p")

        # Group articles by source
        articles_by_source = {}
        for article in articles:
            source = article.get("source", "Unknown")
            if source not in articles_by_source:
                articles_by_source[source] = []
            articles_by_source[source].append(article)

        html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Competitive Intelligence Dashboard</title>
    <style>
        * {{ margin: 0; padding: 0; box-sizing: border-box; }}
        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
            padding: 20px;
        }}
        .container {{ max-width: 1200px; margin: 0 auto; background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }}
        h1 {{ color: #2c3e50; margin-bottom: 10px; border-bottom: 3px solid #3498db; padding-bottom: 10px; }}
        .timestamp {{ color: #7f8c8d; font-size: 14px; margin-bottom: 20px; }}
        .metrics {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 20px 0; }}
        .metric-card {{ background: #ecf0f1; padding: 15px; border-radius: 5px; border-left: 4px solid #3498db; }}
        .metric-card h3 {{ color: #2c3e50; font-size: 14px; margin-bottom: 5px; }}
        .metric-card .value {{ font-size: 28px; font-weight: bold; color: #3498db; }}
        .section {{ margin: 30px 0; }}
        .section h2 {{ color: #2c3e50; border-bottom: 2px solid #ecf0f1; padding-bottom: 10px; margin-bottom: 15px; }}
        .source-group {{ margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 5px; }}
        .source-group h3 {{ color: #2c3e50; margin-bottom: 10px; }}
        .article {{ margin: 10px 0; padding: 10px; background: white; border-radius: 3px; border-left: 3px solid #95a5a6; }}
        .article.critical {{ border-left-color: #e74c3c; }}
        .article.high {{ border-left-color: #f39c12; }}
        .article.medium {{ border-left-color: #3498db; }}
        .article-title {{ font-weight: bold; color: #2c3e50; margin-bottom: 5px; }}
        .article-title a {{ color: #2c3e50; text-decoration: none; }}
        .article-title a:hover {{ color: #3498db; text-decoration: underline; }}
        .article-meta {{ font-size: 12px; color: #7f8c8d; margin-bottom: 5px; }}
        .article-summary {{ font-size: 14px; color: #555; line-height: 1.4; }}
        .priority-badge {{ display: inline-block; padding: 2px 8px; border-radius: 3px; font-size: 11px; font-weight: bold; text-transform: uppercase; }}
        .priority-critical {{ background: #e74c3c; color: white; }}
        .priority-high {{ background: #f39c12; color: white; }}
        .priority-medium {{ background: #3498db; color: white; }}
        .priority-low {{ background: #95a5a6; color: white; }}
        footer {{ margin-top: 40px; padding-top: 20px; border-top: 1px solid #ecf0f1; text-align: center; color: #7f8c8d; font-size: 12px; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>AI Competitive Intelligence Dashboard</h1>
        <div class="timestamp">Generated: {report_date}</div>

        <div class="section">
            <h2>Key Metrics</h2>
            <div class="metrics">
                <div class="metric-card">
                    <h3>Sources Monitored</h3>
                    <div class="value">{stats.get('successful_sources', 0)}/{stats.get('total_sources', 0)}</div>
                </div>
                <div class="metric-card">
                    <h3>New Articles</h3>
                    <div class="value">{stats.get('articles_after_deduplication', 0)}</div>
                </div>
                <div class="metric-card">
                    <h3>Duplicates Removed</h3>
                    <div class="value">{stats.get('duplicates_removed', 0)}</div>
                </div>
                <div class="metric-card">
                    <h3>Success Rate</h3>
                    <div class="value">{self._calculate_success_rate(stats)}%</div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Critical Developments</h2>
"""

        # Add critical articles
        critical_articles = [a for a in articles if a.get("priority") == "critical"]
        if critical_articles:
            for article in critical_articles[:10]:
                html += self._format_article_html(article)
        else:
            html += '<p style="color: #7f8c8d;">No critical developments in this period.</p>'

        html += """
        </div>

        <div class="section">
            <h2>All Sources</h2>
"""

        # Add articles by source
        for source, source_articles in sorted(articles_by_source.items()):
            html += f'<div class="source-group"><h3>{source}</h3>'
            for article in source_articles[:5]:  # Top 5 per source
                html += self._format_article_html(article)
            html += "</div>"

        html += """
        </div>

        <footer>
            <p>AI Competitive Intelligence Tracker | Enterprise-Grade Monitoring System</p>
        </footer>
    </div>
</body>
</html>
"""

        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)
        output_file.write_text(html)

        logger.success(f"HTML dashboard saved to: {output_path}")

    def _format_article_html(self, article: Dict[str, Any]) -> str:
        """Format article as HTML."""
        title = article.get("title", "No Title")
        link = article.get("link", "#")
        date = article.get("date_formatted", "Date unknown")
        priority = article.get("priority", "medium")
        summary = article.get("summary", "")[:200]

        return f"""
        <div class="article {priority}">
            <div class="article-title">
                <a href="{link}" target="_blank">{title}</a>
                <span class="priority-badge priority-{priority}">{priority}</span>
            </div>
            <div class="article-meta">{date}</div>
            <div class="article-summary">{summary}</div>
        </div>
"""

    def _calculate_success_rate(self, stats: Dict[str, Any]) -> float:
        """Calculate success rate."""
        total = stats.get("total_sources", 0)
        successful = stats.get("successful_sources", 0)
        if total == 0:
            return 0.0
        return round((successful / total) * 100, 1)


class ReportGenerator:
    """Main report generator coordinating all output formats."""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        reporting_config = config.get("reporting", {})

        self.output_dir = Path(reporting_config.get("output_dir", "data/reports"))
        self.formats = reporting_config.get("formats", ["markdown", "json", "html", "csv"])

        # Initialize format generators
        self.generators = {
            "markdown": MarkdownReportGenerator(),
            "json": JSONReportGenerator(),
            "html": HTMLReportGenerator(),
            "csv": CSVReportGenerator(),
        }

    def generate_reports(self, data: Dict[str, Any]) -> Dict[str, str]:
        """Generate reports in all configured formats."""
        logger.info("Starting report generation")

        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        generated_files = {}

        for format_name in self.formats:
            if format_name not in self.generators:
                logger.warning(f"Unknown format: {format_name}")
                continue

            try:
                # Determine file extension
                extensions = {
                    "markdown": "md",
                    "json": "json",
                    "html": "html",
                    "csv": "csv",
                }
                ext = extensions.get(format_name, format_name)

                # Generate output path
                output_path = self.output_dir / f"intelligence_report_{timestamp}.{ext}"

                # Generate report
                generator = self.generators[format_name]
                generator.generate(data, str(output_path))

                generated_files[format_name] = str(output_path)

            except Exception as e:
                logger.error(f"Failed to generate {format_name} report: {e}")

        logger.success(f"Report generation complete. Files: {list(generated_files.values())}")
        return generated_files
